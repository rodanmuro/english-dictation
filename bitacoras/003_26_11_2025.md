# BitÃ¡cora 003 - 26/11/2025

## Phase 2.3: YouTube Service - COMPLETED âœ…

### Objective
Implement YouTube audio download service with caching support and async operation.

---

## Work Completed

### 1. YouTube Service Implementation (`app/services/youtube_service.py`)

**Created:** Complete YouTube audio download service using yt-dlp library

**Functions Implemented:**

#### `download_audio(video_id: str) -> Dict[str, str]`
Main async function for downloading and converting YouTube audio.

**Features:**
- Downloads best quality audio from YouTube
- Converts to MP3 format (192 kbps bitrate)
- Async/await support using thread pool executor
- Smart caching - skips download if file already exists
- Saves video metadata (info.json) for title retrieval
- Returns video ID, title, and audio file path

**Configuration:**
- Output format: MP3
- Quality: 192 kbps
- Uses FFmpeg for audio extraction
- Saves metadata JSON for future reference

**Return Value:**
```python
{
    "video_id": "jNQXAC9IVRw",
    "title": "Me at the zoo",
    "audio_path": "app/static/audios/jNQXAC9IVRw.mp3"
}
```

#### `get_audio_path(video_id: str) -> str`
Helper function to get the file path for a video's audio file.

**Usage:**
```python
path = get_audio_path("jNQXAC9IVRw")
# Returns: "app/static/audios/jNQXAC9IVRw.mp3"
```

#### `audio_exists(video_id: str) -> bool`
Check if audio file already exists for a video.

**Usage:**
```python
exists = audio_exists("jNQXAC9IVRw")
# Returns: True/False
```

---

### 2. Environment Setup

**Created:** `.env` file with configuration
- `DEEPGRAM_API_KEY` - Placeholder for testing
- `AUDIO_DIR` - Path for audio storage

**Note:** `.env` file is gitignored for security

---

### 3. Dependencies Installation

**Installed all required Python packages:**
- fastapi (0.122.0) - Web framework
- uvicorn (0.38.0) - ASGI server
- jinja2 - Template engine
- python-multipart (0.0.20) - Form handling
- yt-dlp (2025.11.12) - YouTube download
- deepgram-sdk (5.3.0) - AI transcription
- deepgram-captions (1.2.0) - Subtitle conversion
- python-dotenv (1.2.1) - Environment variables
- aiofiles (25.1.0) - Async file operations
- pydantic-settings (2.12.0) - Settings management
- Plus dependencies: starlette, httptools, watchfiles, websockets, etc.

**Total packages installed:** 18

---

### 4. Testing Infrastructure

**Created:** Comprehensive test suite for YouTube service

**Test File:** `tests/test_youtube_service.py`

**Test Coverage:**

1. **Download Test**
   - Downloads actual YouTube video ("Me at the zoo" - first YouTube video)
   - Verifies file creation and size
   - Checks metadata extraction (title)
   - Confirms MP3 conversion

2. **Caching Test**
   - Calls download function twice
   - Verifies second call skips download
   - Confirms cached data is returned correctly

3. **Helper Functions Test**
   - Tests `get_audio_path()` function
   - Tests `audio_exists()` function

**Test Results:** âœ… ALL TESTS PASSED

**Test Video Details:**
- Video ID: `jNQXAC9IVRw`
- Title: "Me at the zoo"
- Duration: ~18 seconds
- Downloaded size: 0.44 MB (446.67 KB)
- Format: MP3 @ 192 kbps

---

## Technical Implementation Details

### Async/Await Pattern
```python
async def download_audio(video_id: str) -> Dict[str, str]:
    # Run blocking yt-dlp operation in thread pool
    loop = asyncio.get_event_loop()
    info = await loop.run_in_executor(None, _download)
    return result
```

**Why this approach:**
- yt-dlp is a blocking library (not async)
- Thread pool executor prevents blocking FastAPI event loop
- Allows concurrent requests while downloading

### Caching Strategy
```python
if os.path.exists(output_path):
    # Return existing file info
    # Read title from .info.json if available
    return cached_result
```

**Benefits:**
- Saves bandwidth and time
- Instant response for previously processed videos
- Metadata preserved in JSON files

### yt-dlp Configuration
```python
ydl_opts = {
    'format': 'bestaudio/best',          # Best audio quality
    'postprocessors': [{
        'key': 'FFmpegExtractAudio',     # Extract audio
        'preferredcodec': 'mp3',         # Convert to MP3
        'preferredquality': '192',       # 192 kbps
    }],
    'writeinfojson': True,               # Save metadata
}
```

---

## Files Created/Modified

**New Files:**
- `app/services/youtube_service.py` - YouTube service (138 lines)
- `tests/test_youtube_service.py` - Test suite (152 lines)
- `.env` - Environment variables (gitignored)
- `app/static/audios/jNQXAC9IVRw.mp3` - Test audio file
- `app/static/audios/jNQXAC9IVRw.info.json` - Test metadata

**Total Code:** ~290 lines

---

## Issues Encountered & Resolved

### Issue 1: Emoji Encoding Error
**Problem:** Unicode emojis in print statements caused SyntaxError
```python
print(f"ðŸ“¥ Downloading...") # Caused error
```

**Solution:** Replaced emojis with ASCII markers
```python
print(f"[DOWNLOAD] Starting download...") # Fixed
```

### Issue 2: Missing Dependencies
**Problem:** `ModuleNotFoundError: No module named 'pydantic_settings'`

**Solution:** Installed all dependencies from requirements.txt
```bash
pip3 install -r requirements.txt
```

### Issue 3: yt-dlp Warnings
**Problem:** JavaScript runtime warnings from yt-dlp
```
WARNING: No supported JavaScript runtime could be found
```

**Solution:** Warnings are non-critical - downloads work correctly without JS runtime. Can be silenced with extractor args if needed.

---

## Test Execution Output

```
============================================================
âœ… ALL TESTS PASSED
============================================================

Download Test: âœ… PASSED
- Downloaded: Me at the zoo (0.44 MB)
- Caching: âœ… Working correctly

Helper Functions: âœ… PASSED
- get_audio_path(): âœ… Working
- audio_exists(): âœ… Working
```

---

## Next Steps

**Remaining Phase 2 Tasks:**

1. **Step 2.4:** Deepgram Service (`services/deepgram_service.py`)
   - Generate SRT files using Deepgram API
   - Use ResponseWrapper pattern for SDK v5 compatibility
   - Implement caching (check if SRT already exists)

2. **Step 2.5:** SRT Parser (`services/srt_parser.py`)
   - Parse SRT file format
   - Convert timestamps (HH:MM:SS,mmm â†’ float seconds)
   - Return JSON array of segments

3. **Step 2.6:** Cache Service (`services/cache_service.py`)
   - Read/write cache.json
   - Store video processing status
   - Manage segments data

**Estimated Time Remaining:** 1-1.5 hours

---

## Performance Metrics

**Download Performance:**
- Video: "Me at the zoo" (18 seconds, ~246 KB webm)
- Download time: ~1 second
- Conversion time: <1 second
- Total processing: ~6 seconds (including site sleep requirement)
- Final MP3 size: 446.67 KB

**Caching Performance:**
- Cached response time: <0.1 seconds
- Bandwidth saved: 100% (no re-download)

---

## Status

âœ… **Phase 2.1: Config - COMPLETED**
âœ… **Phase 2.2: Video Utils - COMPLETED**
âœ… **Phase 2.3: YouTube Service - COMPLETED**
âœ… **Testing: YouTube Service - COMPLETED (All tests passing)**
â³ **Phase 2.4: Deepgram Service - PENDING**
â³ **Phase 2.5: SRT Parser - PENDING**
â³ **Phase 2.6: Cache Service - PENDING**

---

## Notes

- yt-dlp is actively maintained and works well with current YouTube
- FFmpeg integration is seamless
- Async implementation prevents blocking during downloads
- Caching significantly improves performance for repeated requests
- Test video ("Me at the zoo") is perfect for testing - short and reliable
- All audio files stored in `app/static/audios/` as configured
- Metadata JSON files enable title retrieval without re-downloading